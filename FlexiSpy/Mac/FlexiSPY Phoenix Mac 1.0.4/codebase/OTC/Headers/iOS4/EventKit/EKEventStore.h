/*
 *     Generated by class-dump 3.3.4 (64 bit).
 *
 *     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2011 by Steve Nygard.
 */

#import <Foundation/Foundation.h>
//#import "NSObject.h"

@class EKCalendar, NSArray, NSMutableArray, NSMutableDictionary, NSString, NSTimeZone;

@interface EKEventStore : NSObject
{
    id _database;
    NSMutableDictionary *_calendars;
    NSMutableDictionary *_sources;
    NSMutableArray *_observers;
    unsigned int _flags;
    NSTimeZone *_timeZone;
}

+ (id)storeWithOptions:(unsigned long)arg1 path:(id)arg2;
- (id)init;
- (id)initWithOptions:(unsigned long)arg1 path:(id)arg2;
- (void)dealloc;
- (void)setTimeZone:(id)arg1;
- (id)timeZone;
- (unsigned int)serverPort;
- (void)databaseChangedExternally;
- (void)daemonRestarted;
@property(readonly, nonatomic) NSArray *calendars;
- (int)readWriteCalendarCount;
- (id)readWriteCalendars;
@property(readonly, nonatomic) NSString *eventStoreIdentifier;
- (id)calendarWithID:(id)arg1;
- (id)sourceWithID:(id)arg1;
- (void)_saveWithNotify:(BOOL)arg1;
- (void)_save;
- (void)_notifyStoreChanged;
- (BOOL)saveCalendar:(id)arg1 error:(id *)arg2;
- (BOOL)saveCalendar:(id)arg1 deferred:(BOOL)arg2 error:(id *)arg3;
- (BOOL)removeCalendar:(id)arg1 error:(id *)arg2;
- (id)eventWithIdentifier:(id)arg1;
- (id)eventForUID:(id)arg1 occurrenceDate:(id)arg2;
- (BOOL)saveEvent:(id)arg1 span:(int)arg2 error:(id *)arg3;
- (BOOL)removeEvent:(id)arg1 span:(int)arg2 error:(id *)arg3;
- (BOOL)setEventParticipationStatus:(id)arg1 status:(int)arg2 applyToAll:(BOOL)arg3 error:(id *)arg4;
- (BOOL)markEventRead:(id)arg1 error:(id *)arg2;
- (id)importICS:(id)arg1 intoCalendar:(id)arg2 options:(unsigned int)arg3;
- (id)importICSData:(id)arg1 intoCalendar:(id)arg2 options:(unsigned int)arg3;
@property(readonly, nonatomic) EKCalendar *defaultCalendarForNewEvents;
- (id)defaultCalendarForNewTasks;
- (id)searchOperationForPredicate:(id)arg1 callback:(id)arg2;
- (id)eventsMatchingPredicate:(id)arg1;
- (void)enumerateEventsMatchingPredicate:(id)arg1 usingBlock:(id)arg2;
- (id)predicateForEventsWithStartDate:(id)arg1 endDate:(id)arg2 calendars:(id)arg3;
- (id)predicateForEventsWithStartDate:(id)arg1 endDate:(id)arg2 eventIdentifier:(id)arg3 calendars:(id)arg4;

// copied from the public header file
/*!
 @constant   EKEventStoreChangedNotification
 @discussion Notification name sent out when the database is changed by either an external process,
 another event store in the same process, or by calling saveEvent: or removeEvent: on a
 store you are managing. When you receive this notification, you should consider all EKEvent
 instances you have to be invalid. If you had selected events for a date range using
 eventsMatchingPredicate, etc. for display, you should release them and re-fetch the events
 again. If you have an event you are actively using (e.g. you are currently viewing details
 for it or editing it), you can call [EKEvent refresh] to try to revalidate it against the
 latest state of the database. If that method returns YES, you can continue to use the event,
 otherwise, you should release it and abandon what you were doing with it. The view
 controllers provided by EventKitUI automatically deal with this for you.
 */
extern NSString *const EKEventStoreChangedNotification __OSX_AVAILABLE_STARTING(__MAC_NA,__IPHONE_4_0);


@end

